"""Test the 'synse.commands.read' Synse Server module."""
# pylint: disable=redefined-outer-name,unused-argument,line-too-long

import os
import shutil

import asynctest
import grpc
import pytest
from synse_grpc import api

import synse.cache
from synse import errors, plugin, utils
from synse.commands.read import read
from synse.proto.client import PluginClient, PluginUnixClient
from synse.scheme.read import ReadResponse


@pytest.fixture(scope='module')
def setup():
    """Fixture to setup/teardown the module tests"""

    # create a temp directory for test data
    if not os.path.isdir('tmp'):
        os.makedirs('tmp')

    # create a dummy file as test data
    open('tmp/foo', 'w').close()

    yield

    if os.path.isdir('tmp'):
        shutil.rmtree('tmp')


def mockgetdevicemeta(rack, board, device):
    """Mock method to monkeypatch the get_device_info method."""
    # the plugin name 'foo' here corresponds to the plugin generated by
    # the `make_plugin` fixture
    return 'vaporio/foo+unix@tmp/foo', api.Device(
        timestamp='october',
        uid='12345',
        kind='thermistor',
        metadata=dict(
            model='test',
            manufacturer='vapor io',
        ),
        plugin='foo',  # this will be the name of the plugin we look up
        info='bar',
        location=api.Location(
            rack='rack-1',
            board='vec'
        ),
        output=[
            api.Output(
                type='temperature',
                precision=3,
                unit=api.Unit(
                    name='celsius',
                    symbol='C'
                )
            )
        ]
    )


def mockread(self, rack, board, device):
    """Mock method to monkeypatch the client read method."""
    return [api.Reading(
        timestamp='october',
        type='temperature',
        int64_value=10
    )]


def mockreadfail(self, rack, board, device):
    """Mock method to monkeypatch the client read method to fail."""
    raise grpc.RpcError()


def patch_client_read_error(self, rack, board, device):
    """Patch the grpc client's read method to raise a gRPC error indicative of
    the "no readings found" case."""
    e = grpc.RpcError()
    e.details = lambda: 'no readings found'
    e.code = lambda: grpc.StatusCode.NOT_FOUND
    raise e


@pytest.fixture()
def mock_get_device_info(monkeypatch):
    """Fixture to monkeypatch the cache device meta lookup."""
    mock = asynctest.CoroutineMock(synse.cache.get_device_info, side_effect=mockgetdevicemeta)
    monkeypatch.setattr(synse.cache, 'get_device_info', mock)
    return mock_get_device_info


@pytest.fixture()
def mock_client_read(monkeypatch):
    """Fixture to monkeypatch the grpc client's read method."""
    monkeypatch.setattr(PluginClient, 'read', mockread)
    return mock_client_read


@pytest.fixture()
def mock_client_read_fail(monkeypatch):
    """Fixture to monkeypatch the grpc client's read method to fail."""
    monkeypatch.setattr(PluginClient, 'read', mockreadfail)
    return mock_client_read_fail


@pytest.fixture()
def mock_client_read_error(monkeypatch):
    """Fixture to monkeypatch the client's read method to error out."""
    monkeypatch.setattr(PluginClient, 'read', patch_client_read_error)
    return mock_client_read_error


@pytest.fixture()
def mock_rfc_time(monkeypatch):
    """Fixture to monkeypatch the util for generating a timestamp so we can
    reliably test the timestamp field.
    """
    monkeypatch.setattr(utils, 'rfc3339now', lambda: 'sometime')
    return mock_rfc_time


@pytest.fixture()
def make_plugin(setup):
    """Fixture to create and register a plugin for testing."""

    plugin_id = 'vaporio/foo+unix@tmp/foo'

    # make a dummy plugin for the tests to use
    if plugin_id not in plugin.Plugin.manager.plugins:
        plugin.Plugin(
            metadata=api.Metadata(
                name='foo',
                tag='vaporio/foo'
            ),
            address='tmp/foo',
            plugin_client=PluginUnixClient('tmp/foo')
        )

    yield

    if plugin_id in plugin.Plugin.manager.plugins:
        del plugin.Plugin.manager.plugins[plugin_id]


@pytest.mark.asyncio
async def test_read_command_no_device():
    """Get a ReadResponse when the device doesn't exist."""

    # FIXME - it would be nice to use pytest.raises, but it seems like it isn't
    # properly trapping the exception for further testing.
    try:
        await read('rack-1', 'vec', '12345')
    except errors.SynseError as e:
        assert e.error_id == errors.DEVICE_NOT_FOUND


@pytest.mark.asyncio
async def test_read_command_no_plugin(mock_get_device_info):
    """Get a ReadResponse when the plugin doesn't exist."""

    # FIXME - it would be nice to use pytest.raises, but it seems like it isn't
    # properly trapping the exception for further testing.
    try:
        await read('rack-1', 'vec', '12345')
    except errors.SynseError as e:
        assert e.error_id == errors.PLUGIN_NOT_FOUND


@pytest.mark.asyncio
async def test_read_command_grpc_err(mock_get_device_info, mock_client_read_fail, make_plugin):
    """Get a ReadResponse when the plugin exists but cant communicate with it."""

    # FIXME - it would be nice to use pytest.raises, but it seems like it isn't
    # properly trapping the exception for further testing.
    try:
        await read('rack-1', 'vec', '12345')
    except errors.SynseError as e:
        assert e.error_id == errors.FAILED_READ_COMMAND


@pytest.mark.asyncio
async def test_read_command_grpc_err_no_reading(mock_get_device_info, mock_client_read_error, make_plugin, mock_rfc_time):
    """Get a ReadResponse when the plugin returns an error indicating no reading."""

    resp = await read('rack-1', 'vec', '12345')

    assert isinstance(resp, ReadResponse)
    assert resp.data == {
        'kind': 'thermistor',
        'data': [
            {
                'info': '',
                'type': 'temperature',
                'value': None,
                'timestamp': 'sometime',
                'unit': {
                    'name': 'celsius',
                    'symbol': 'C'
                }
            }
        ]
    }


@pytest.mark.asyncio
async def test_read_command(mock_get_device_info, mock_client_read, make_plugin):
    """Get a ReadResponse when the plugin exists."""

    resp = await read('rack-1', 'vec', '12345')

    assert isinstance(resp, ReadResponse)
    assert resp.data == {
        'kind': 'thermistor',
        'data': [
            {
                'info': '',
                'type': 'temperature',
                'value': 10.0,
                'timestamp': 'october',
                'unit': {
                    'name': 'celsius',
                    'symbol': 'C'
                }
            }
        ]
    }
